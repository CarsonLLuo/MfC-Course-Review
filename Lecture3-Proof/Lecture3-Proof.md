# Lecture3-Proof

证明P→Q形式的命题的真值**。**有几种标准的证明方法，它们都能排除P为真且Q为假的情况，回想一下，这是唯一的P→Q为假的情况。

1. **直接证明（Direct Argument）：** 假设 P 为真，并展示出 Q 也为真的证据。这种证明方法通过直接推导出结论 Q 来证明命题 P ⇒ Q 的真实性。

例子： 假设 P 表示"如果一个整数是偶数，则它可以被2整除"，Q 表示"一个整数是被2整除的"。为了证明 P ⇒ Q，我们可以假设一个整数是偶数（P 为真），然后通过直接的推理得出这个整数可以被2整除（Q 为真）。

2. **逆否证明（Contrapositive Argument）：** 假设 Q 为假，并展示出 P 也为假的证据。这种证明方法通过证明命题的逆否命题来证明原命题的真实性。

例子： 假设 P 表示"如果一个数是平方数，那么它是非负数"，Q 表示"一个数是非负数"。为了证明 P ⇒ Q，我们可以假设一个数不是非负数（Q 为假），然后通过逆否命题的推理得出这个数不是平方数（P 为假）。

3. **反证法证明（Proof by Contradiction）：** 假设 P 为真且 Q 为假，并通过推导出矛盾的结论来证明这种情况是不可能的。这种证明方法通过推导出矛盾来否定假设，从而得出结论。

例子： 假设 P 表示"存在无理数 a 和 b，使得 a ÷ b 是有理数"，Q 表示"a ÷ b 是有理数"。为了证明 P ⇒ Q，我们可以假设存在无理数 a 和 b，使得 a ÷ b 是无理数（Q 为假），然后通过推导出无理数除以无理数得到有理数这一矛盾的结论，从而否定了假设。

# 前置条件和后置条件	

1. **前置条件（Precondition）：** 前置条件是指在执行函数或方法之前必须满足的条件或状态。它描述了调用函数或方法时的先决条件，即函数执行前的要求或假设条件。如果前置条件未满足，那么函数的行为和结果可能是不确定的。  
    例如，对于一个计算平方根的函数，其前置条件可能是输入参数必须为非负数。在调用该函数之前，必须确保输入参数满足这个条件，否则函数可能无法正常执行或返回无效的结果。
2. **后置条件（Postcondition）：** 后置条件是指在执行函数或方法之后应该满足的条件或状态。它描述了函数执行后的结果或保证条件。后置条件用于指定函数的预期行为和返回值。  
    继续上面的例子，对于计算平方根的函数，其后置条件可以是返回值必须是非负数。调用函数后，可以根据后置条件来验证函数的正确性，并确保其返回结果满足预期。

# 归纳法

归纳法是一种数学推理方法，用于证明一个命题在所有自然数或一组有序元素上的通用性。它基于以下思想：如果我们能够证明一个命题在某个特定情况下成立，并且证明它在下一个情况下的成立能够由前一个情况的成立推导出来，那么我们可以通过不断迭代这个过程，证明该命题对所有情况都成立。

归纳法通常包含两个步骤：

1. **基础步骤（Base Case）：** 首先，我们需要证明命题在最小的情况下成立，通常是证明命题在 n=1 或 n=0（或其他适用的最小值）时成立。
2. **归纳步骤（Inductive Step）：** 其次，我们假设命题在某个特定情况下成立，通常是假设命题在第 k 情况下成立，并证明命题在下一个情况，即第 k+1 情况下也成立。

通过这两个步骤的结合，我们可以推断命题在所有情况下成立，从而完成归纳法的证明。

‍

举个例子，我们来使用归纳法证明一个简单的命题：所有正整数 n 的和可以通过公式 $1 + 2 + 3 + ... + n = n(n+1)/2$ 来计算。

**基础步骤：** 当 $n=1$ 时，左边的和为 1，右边的计算结果为 $1(1+1)/2 = 1$。因此，基础步骤成立。

**归纳步骤：** 假设对于某个正整数 k，命题成立，即 $1 + 2 + 3 + ... + k = k(k+1)/2$。现在我们来证明命题对于下一个情况，即 n=k+1 也成立。

根据归纳假设，我们假设 $1 + 2 + 3 + ... + k = k(k+1)/2$。我们将这个等式左边加上$k+1$，右边加上 $(k+1)$。这样，我们得到：

$1 + 2 + 3 + ... + k + (k+1) = k(k+1)/2 + (k+1)$

我们可以对右边的式子进行化简：$1+2+3+...+k+(k+1)=(k+1)(k+2) / 2$

因此，命题对于 n=k+1 也成立。

通过基础步骤和归纳步骤的证明，我们可以得出结论：对于所有正整数 n，命题成立。因此，我们使用归纳法证明了这个命题的通用性。
